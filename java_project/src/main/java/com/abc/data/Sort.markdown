# Sort
关于Java数据结构和算法的具体实现见：[java-algorithm](https://github.com/zhangga/java-algorithm)  
这里只是做一个概括性总结。

### 冒泡排序
简介：每趟排序依次比较相邻的两个项，将较大项交换到后面，一趟下来最大项就冒泡到最后一个。  
时间复杂度：O(n^2)。比较次数n^2，交换次数最坏的情况下n^2。  
最好情况：数据正序，每次比较都不需要交换。  
最坏情况：数据倒序，每次比较都得交换。

### 选择排序
简介：对冒泡排序的改进。每趟排序不再将较大项交换到后面，而是选择出最小(大)项，将其放到对应位置。
时间复杂度：O(n^2)。比较次数n^2，交换次数最坏的情况下减少到了n。  
最好情况：数据正序，每趟选择都不需要交换。  
最坏情况：数据倒序，每趟选择都得交换。

### 插入排序
简介：假设一个标识位的左边是排好序的数组，右边是未排序的数据。只需要从标识位开始依次将右边的未排序数据插入到已排序数组的合适位置即可。  
时间复杂度：O(n^2)。比较次数最坏情况n^2，复制次数最坏的情况下n^2。  
最好情况：数据正序，比较次数n，复制次数n  
最坏情况：数据倒序，比较次数n^2，复制次数n^2  

#### 总结
上面三种简单排序都不需要使用额外空间来进行排序，在时间效率上大部分情况下冒泡排序是效率最低的，一般不建议选择冒泡排序。  
选择排序在冒泡排序的基础上减少了交换的次数，插入排序用复制代替交换提高了效率，大部分情况下插入排序是上面三种排序中效率最高的。  
对已经有序或基本有序的数据来说，插入排序几乎只需要O(n)的时间，但是对于逆序数据来说，插入排序不比冒泡排序快，
所以插入排序也是不稳定的排序，具体选择哪种排序算法还需要根据具体场景来选择。

### 归并排序
简介：将两个已排序好的数组合并成一个有序的数组。利用分治的思想，将数据不停的二分，直到一个数据时就是已排序的子数组。  
时间复杂度：O(n*logn)。需要进行logn次merge，每次merge需要n次比较和复制。  
空间：需要额外的和原数组大小相同的空间用来进行合并操作。

### 希尔排序
简介：采用h = 3*h + 1的增量进行插入排序。增量选择的原则，尽量互质，这样每一趟排序尽量可以保持前一趟排好的结果。  
时间复杂度：根据增量选择的不同时间复杂度不同，可以近似O(n*(logn)^2)

### 划分
简介：划分算法是快速排序算法的基础。以一个值为基准，左右两个指针向中间靠拢，小于该值的数放在一边，大于该值的数放到另一边。  
时间复杂度：O(n)。比较次数N。  
最坏情况：数据倒序，交换次数N/2。

### 快速排序
简介：选取一个中值，将小于该值的划分到一边，大于该值的划分到另一边。对子数组递归的调用划分。  
时间复杂度：O(n*logn)。  
最坏情况：数据倒序，时间O(n^2)。  
优化方法：选取中值，使用三数据项取中。小划分使用插入排序。
